# -*- coding: utf-8 -*-
"""T3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QgVIuEwCPgGFX2S4nJDdAef3yaNxnxE3
"""

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np
import sklearn.metrics
from sklearn.cluster import KMeans, AgglomerativeClustering, DBSCAN, OPTICS, cluster_optics_dbscan
from sklearn.preprocessing import StandardScaler
from scipy.cluster.hierarchy import dendrogram, linkage

data = pd.read_csv('StudentsPerformance.csv')
data = data.rename(columns={'race/ethnicity' : 'ethnicity',
                            'parental level of education' : 'parentalLevelEducation',
                            'test preparation course' : 'preparationCourse',
                            'math score' : 'mathScore',
                            'reading score' : 'readingScore',
                            'writing score': 'writingScore'})

print("Colunas: {0}\n".format(data.columns))
print(data.info())
print("Formato do conjunto de dados {0}".format(data.shape))

scores = data.loc[:,["mathScore","readingScore","writingScore"]]

"""# Visualização dos dados

### Gênero dos participantes
"""

sns.pairplot(data, kind="scatter", hue="gender")
plt.show()

"""### Etnicidade dos participantes"""

sns.pairplot(data, kind="scatter", hue="ethnicity")
plt.show()

"""### Nível de educação dos pais"""

sns.pairplot(data, kind="scatter", hue="parentalLevelEducation")
plt.show()

"""### Curso preparatório"""

sns.pairplot(data, kind="scatter", hue="preparationCourse")
plt.show()

fig, axs = plt.subplots(1, 5, figsize=(16, 3), sharey=True)

sns.countplot(data.gender, ax = axs[0])

ax0 = sns.countplot(data["ethnicity"], ax = axs[1])
ax0.set_xticklabels(ax0.get_xticklabels(), rotation=90)

ax1 = sns.countplot(data["parentalLevelEducation"], ax = axs[2])
ax1.set_xticklabels(ax1.get_xticklabels(), rotation=90)

sns.countplot(data.lunch, ax = axs[3])

sns.countplot(data["preparationCourse"], ax = axs[4])

"""# Clustering"""

wcss = []
print('Valores do WCSS')
for i in range(1, 11):
    kmeans = KMeans(n_clusters = i, random_state = 0)
    kmeans.fit(scores)
    print("[{0}]\t{1:10.3f}".format(i, kmeans.inertia_))
    wcss.append(kmeans.inertia_)
    
plt.plot(range(1, 11), wcss)
plt.xlabel('Número de clusters')
plt.ylabel('WCSS')
plt.title('Algoritmo: KMeans')
plt.show()

print("KMeans com 4 clusteres")
kmeans = KMeans(n_clusters = 4, random_state = 0)
previsoes = kmeans.fit_predict(scores)
data['resultados'] = previsoes
resultadoKMEANS = data['resultados']

print("Coeficiente de Silhueta média: %0.3f" % sklearn.metrics.silhouette_score(scores, kmeans.labels_))
print("Coeficiente de Davies Bouldin: %0.3f" % sklearn.metrics.davies_bouldin_score(scores, kmeans.labels_))
print("Coeficiente de Calinski Harabasz: %0.3f\n" % sklearn.metrics.calinski_harabasz_score(scores, kmeans.labels_))
unicos, quantidade = np.unique(previsoes, return_counts = True)
for u, q in zip(unicos, quantidade):
    print("Classe {0}:\t{1} elementos na classe".format(u,q))

data.groupby("resultados").aggregate("mean").plot.bar()
plt.xlabel('Classes')
plt.ylabel('Nota média')
plt.title('Algoritmo: KMeans')
plt.legend(['Matemática','Leitura','Escrita'])
plt.show()

plt.hist(data['resultados'])
plt.xlabel('Classes')
plt.ylabel('Quantidade')
plt.show()

dendograma = dendrogram(linkage(scores, method='ward'))
plt.title('Dendrograma')
plt.xlabel('Notas')
plt.ylabel('Distância Euclidiana')
plt.show()

hc = AgglomerativeClustering(n_clusters = 4, affinity = 'euclidean', linkage = 'ward')
previsoes = hc.fit_predict(scores)
data['resultados'] = previsoes
resultadoAGGLOMERATIVE = data['resultados']

print("Coeficiente de Silhueta média: %0.3f" % sklearn.metrics.silhouette_score(scores, hc.labels_))
print("Coeficiente de Davies Bouldin: %0.3f" % sklearn.metrics.davies_bouldin_score(scores, hc.labels_))
print("Coeficiente de Calinski Harabasz: %0.3f\n" % sklearn.metrics.calinski_harabasz_score(scores, hc.labels_))
unicos, quantidade = np.unique(previsoes, return_counts = True)
for u, q in zip(unicos, quantidade):
    print("Classe {0}:\t{1} elementos na classe".format(u,q))

data.groupby("resultados").aggregate("mean").plot.bar()
plt.xlabel('Classes')
plt.ylabel('Nota média')
plt.title('Algoritmo: Agglomerative Clustering')
plt.legend(['Matemática','Leitura','Escrita'])
plt.show()

plt.hist(data['resultados'])
plt.xlabel('Classes')
plt.ylabel('Quantidade')
plt.show()

dbscan = DBSCAN(eps = 4.3, min_samples = 4)
previsoes = dbscan.fit_predict(scores)
unicos, quantidade = np.unique(previsoes, return_counts = True)
print("DBSCAN com Min Samples {0}".format(4))
print("Coeficiente de Silhueta média: %0.3f" % sklearn.metrics.silhouette_score(scores, dbscan.labels_))
print("Coeficiente de Davies Bouldin: %0.3f" % sklearn.metrics.davies_bouldin_score(scores, dbscan.labels_))
print("Coeficiente de Calinski Harabasz: %0.3f\n" % sklearn.metrics.calinski_harabasz_score(scores, dbscan.labels_))
for u, q in zip(unicos, quantidade):
    print("Classe {0}:\t{1} elementos na classe".format(u,q))

data['resultados'] = previsoes
resultadoDBSCAN = data['resultados']
pd.set_option('display.max_columns', None)  
pd.set_option('display.expand_frame_repr', False)
pd.set_option('max_colwidth', -1)

data['resultados'] = previsoes
data.groupby("resultados").aggregate("mean").plot.bar()
plt.title('Algoritmo: DBSCAN')
plt.legend(['Matemática','Leitura','Escrita'])
plt.xlabel('Classes')
plt.ylabel('Nota média')
plt.show()


plt.hist(data['resultados'])
plt.xlabel('Classes')
plt.ylabel('Quantidade')
plt.show()

clust = OPTICS(min_samples=20, min_cluster_size=15)
previsoes = clust.fit_predict(scores)
unicos, quantidade = np.unique(previsoes, return_counts = True)
print("Optics com Min Samples {0}".format(20))
print("Coeficiente de Silhueta média: %0.3f" % sklearn.metrics.silhouette_score(scores, clust.labels_))
print("Coeficiente de Davies Bouldin: %0.3f" % sklearn.metrics.davies_bouldin_score(scores, clust.labels_))
print("Coeficiente de Calinski Harabasz: %0.3f\n" % sklearn.metrics.calinski_harabasz_score(scores, clust.labels_))
for u, q in zip(unicos, quantidade):
    print("Classe {0}:\t{1} elementos na classe".format(u,q))
data['resultados'] = previsoes
resultadoOPTICS = data['resultados']

data.groupby("resultados").aggregate("mean").plot.bar()
plt.title('Algoritmo: OPTICS')
plt.legend(['Matemática','Leitura','Escrita'])
plt.xlabel('Classes')
plt.ylabel('Nota média')
plt.show()


plt.hist(data['resultados'])
plt.xlabel('Classes')
plt.ylabel('Quantidade')
plt.show()

resultados = [resultadoKMEANS, resultadoAGGLOMERATIVE, resultadoDBSCAN, resultadoOPTICS]
labelResultados = ["KMeans", "Agglomerative Clustering", "DBSCAN", "OPTICS"]
for r, l in zip(resultados, labelResultados):
    data['resultados'] = r
    data.loc[data['resultados'] == 2, 'grade'] = "A"
    data.loc[data['resultados'] == 0, 'grade'] = "B"
    data.loc[data['resultados'] == 1, 'grade'] = "C"
    data.loc[data['resultados'] == 3, 'grade'] = "D"
    data.loc[data['resultados'] == 4, 'grade'] = "F"

    print("Gráfico " + l)
    sns.pairplot(data, hue='grade', diag_kind='hist')
    plt.show()

